// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: quotes.sql

package db

import (
	"context"
)

const countQuotes = `-- name: CountQuotes :one
SELECT COUNT(*) FROM quotes
`

func (q *Queries) CountQuotes(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countQuotes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createQuote = `-- name: CreateQuote :one
INSERT INTO quotes (user_id, content, author) VALUES ($1, $2, $3) RETURNING id, user_id, content, author, created_at
`

type CreateQuoteParams struct {
	UserID  int32  `json:"user_id"`
	Content string `json:"content"`
	Author  string `json:"author"`
}

func (q *Queries) CreateQuote(ctx context.Context, arg CreateQuoteParams) (*Quote, error) {
	row := q.db.QueryRow(ctx, createQuote, arg.UserID, arg.Content, arg.Author)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.Author,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteQuote = `-- name: DeleteQuote :one
DELETE FROM quotes WHERE id = $1 RETURNING id, user_id, content, author, created_at
`

func (q *Queries) DeleteQuote(ctx context.Context, id int32) (*Quote, error) {
	row := q.db.QueryRow(ctx, deleteQuote, id)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.Author,
		&i.CreatedAt,
	)
	return &i, err
}

const getAllQuotes = `-- name: GetAllQuotes :many
SELECT id, user_id, content, author, created_at FROM quotes ORDER BY created_at DESC
`

func (q *Queries) GetAllQuotes(ctx context.Context) ([]*Quote, error) {
	rows, err := q.db.Query(ctx, getAllQuotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Quote
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.Author,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllQuotesByUser = `-- name: GetAllQuotesByUser :many
SELECT id, user_id, content, author, created_at FROM quotes WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetAllQuotesByUser(ctx context.Context, userID int32) ([]*Quote, error) {
	rows, err := q.db.Query(ctx, getAllQuotesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Quote
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.Author,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuoteByID = `-- name: GetQuoteByID :one
SELECT id, user_id, content, author, created_at FROM quotes WHERE id = $1
`

func (q *Queries) GetQuoteByID(ctx context.Context, id int32) (*Quote, error) {
	row := q.db.QueryRow(ctx, getQuoteByID, id)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.Author,
		&i.CreatedAt,
	)
	return &i, err
}

const getQuotesByUserID = `-- name: GetQuotesByUserID :one
SELECT id, user_id, content, author, created_at FROM quotes WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetQuotesByUserID(ctx context.Context, userID int32) (*Quote, error) {
	row := q.db.QueryRow(ctx, getQuotesByUserID, userID)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.Author,
		&i.CreatedAt,
	)
	return &i, err
}

const searchQuotes = `-- name: SearchQuotes :one
SELECT id, user_id, content, author, created_at FROM quotes WHERE content ILIKE '%' || $1 || '%' OR author ILIKE '%' || $1 || '%' ORDER BY created_at DESC
`

func (q *Queries) SearchQuotes(ctx context.Context, dollar_1 *string) (*Quote, error) {
	row := q.db.QueryRow(ctx, searchQuotes, dollar_1)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.Author,
		&i.CreatedAt,
	)
	return &i, err
}

const updateQuote = `-- name: UpdateQuote :one
UPDATE quotes SET content = $2, author = $3 WHERE id = $1 RETURNING id, user_id, content, author, created_at
`

type UpdateQuoteParams struct {
	ID      int32  `json:"id"`
	Content string `json:"content"`
	Author  string `json:"author"`
}

func (q *Queries) UpdateQuote(ctx context.Context, arg UpdateQuoteParams) (*Quote, error) {
	row := q.db.QueryRow(ctx, updateQuote, arg.ID, arg.Content, arg.Author)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.Author,
		&i.CreatedAt,
	)
	return &i, err
}
